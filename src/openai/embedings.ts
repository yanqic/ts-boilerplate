import { Configuration, OpenAIApi } from 'openai';
import * as dotenv from 'dotenv';
dotenv.config();
import fs from 'fs';

const configuration = new Configuration({
    apiKey: process.env.OPENAI_API_KEY,
    basePath: process.env.OPENAI_BASE_PATH
});
const openai = new OpenAIApi(configuration);

const datasets = [
    {
        question: '你是谁，老虎工单有什么功能？',
        answer: '我是工单小助手，一个由老虎工单知识库训练的机器人。我可以提供工单系统操作指南，各种业务问题处理建议等。如果您有任何问题或需要协助，请随时告诉我，我会尽力帮助您。'
    },
    {
        question: '我什么时候应当关闭工单？',
        answer: '1. 当工单所涉及的问题已经处理结束或者得出共识结论时，就可以关闭工单了\n2. 如果该问题的处理需要更多时间，可以适当调整截止时间，并继续跟进工单问题处理\n3. 如果该问题需要排期解决，或者延迟版本跟进，可以将该问题记录到Jira或者Asana上，然后将相关链接贴到工单详情中，就可以关闭工单了'
    },
    {
        question: '什么是隐私工单？',
        answer: '隐私工单的详情、评论、更新日志等都只允许报告人、负责人、协作人、关注人可以看到，这个可以用来控制一些涉及敏感信息的工单的可见范围，避免信息大面积泄露'
    },
    {
        question: '老虎工单审批有什么作用？',
        answer: '工单创建人可以打开工单审批选项，这样其他人员在尝试将工单关闭时就会自动创建一条飞书审批给创建人，创建人可以决定是否通过OR拒绝，以二次确认工单涉及问题确实已经处理完毕'
    },
    {
        question: '我不知道该把工单负责人指派给谁？',
        answer: '不用苦恼，我们有专门的技术支持团队。如果你不清楚遇到的问题该找谁，请创建工单并一股脑儿的指派给【技术支持】'
    },
    {
        question: '工单通知到群是怎么回事？',
        answer: '您可以选择将工单同步到一些群会话中，当工单状态变更时将会自动发送消息到群组中，方便群中人员信息共享'
    },
    {
        question: '我已经不是负责人了，为什么还收到飞书日程、任务通知？',
        answer: '当工单负责人变更时，原负责人会被自动添加到协作人中。在工单系统中，负责人和协作人都会收到飞书日程和待办。如果你不再是负责人，也不需要作为协作人关注工单进展，那么你可以将自己从协作人中移除，那么你的飞书日程和待办也将一并关闭。但是，请注意，将自己从协作人移除后，你将一并丧失工单编辑权限，即无法继续对工单进行修改变更（包括再将自己添加回协作人）'
    },
    {
        question: '老虎工单负责人和协作人有什么不同？',
        answer: 'JIRA只有一个经办人（负责人），那么工单为什么设计出负责人和协作人两种角色呢？在实践中，一个问题的解决往往需要多方共同参与，JIRA大多是单向流转，这个效率会比较低（一方处理完再转给下一个），我们希望能同时将工单分配给需要参与的人。而多个人同时参与工单处理时，需要有个主负责人（类似于项目开发中的项目经理，不能群龙无首），可以对工作进行分解安排和对结果负责。\n所以工单中区分了负责人和协作人。一个工单的负责人应当尽可能保持稳定，不应当变来变去的。当负责人无法独立完成问题处理时，他可以将他依赖的其他人添加为协作人，共同参与完成工作。当然，你依然可以将工单像JIRA那样单向流转，但是请注意在工单中，原负责人会自动变为协作人。如果自己不再是负责人后，想彻底不再收到该工单的通知和日程提醒，可以将自己从协作人关注人中移除。'
    },
    {
        question: '我希望能添加一些分类和项目 ｜希望xx分类/xx项目下的工单能够自定义一些字段？',
        answer: '工单目前支持编辑的字段是经过考虑取舍后的，我们希望无论是作为研发、产品等主要问题解决方，还是客服、运营、商务、市场、财务行政等，大家都能对工单的基本操作和使用有一个简单的上手使用和理解，降低使用门槛。目前工单详情和客户信息两个维度的字段下，基本能够覆盖绝大多数场景下的内容添加。\n如果个别场景下希望有新的字段可以编辑（可以使用客户信息下的最定义字段功能），或者希望添加一些新的项目、分类等，那么建议考虑使用标签功能。标签可以自由随意添加，完全可以用来打标记、做分类。\n我们也会后续总结梳理大家的各类反馈，对一些预定义的字段或者特殊类型的工单支持一些定制化的流转流程和功能支持。'
    },
    {
        question: '老虎工单的状态有哪几种？发布工单/删除工单/恢复工单/重新打开等有什么区别？',
        answer: '工单的状态我们只做了简单的区分，但是根据工单预期完成时间的不同，以及对工单删除操作带来的变化，在前台显示出的状态会有以下几种：\n- 草稿 - 刚创建未发布的工单，该工单仅创建人本人可见\n- 待跟进 - 发布出去的工单（当前要求发布工当前必须指定负责人，后续在梳理了工单的流转SOP后，会放开这个限制）\n- 跟进中 - 已经指定了负责人的进行中的工单\n- 已超时 - 超出预期完成时间依然没有结束的工单- 已解决 - 工单已被标记为解决\n- 已中止 - 工单已被标记为中止\n- 已删除 - 工单被创建人删除，已删除的工单仅创建人可见根据以上状态，所以几个对工单的操作的含义就明确了：\n- 发布工单 - 即将工单由草稿状态更改为跟进中\n- 删除工单 - 即删除自己创建的工单\n- 恢复工单 - 即将删除的工单重新恢复\n- 解决工单 - 即将工单变更为已解决\n- 中止工单 - 即将工单变更为已中止\n- 重新打开 - 即将已经解决/中止的工单重新变更为跟进中'
    },
    {
        question: '一个工单跟踪的问题需要很长时间解决，应该怎么办？',
        answer: '工单注重于快速跟进和解决问题，如果一个工单所涉及的问题暂时不具备解决条件，或者需要很长的一个解决周期，那么建议可以中止该工单，备注清楚原因，然后通过Asana创建project并分解task来专门处理；如果属于bug，可以请QA同事创建相关的JIRA任务来跟踪解决。'
    },
    {
        question: '什么是用户组？',
        answer: '用户组为一组用户所构成的值班组，由工单管理员创建和管理。当工单需要指派负责人时，可以选择相关用户组，该用户组成员都将收到工作通知和日程安排。\n用户组主要用于当不清楚具体负责人该是谁时的工单指派。一些一线部门有各自的问题场景对接处理的SOP，工单管理员会针对这些场景，添加对应的工单值班组。在创建工单后，在不清楚具体对接人的情况下，可以选择将工单指派给相关的用户组，例如：\n当有客户反映交易订单无法撤销时，客服创建一个工单并指派给【交易订单值班】用户组，而无需关心到底该找产品还是研发、这个人今天是否请假、是否可以尽快处理等问题'
    },
    {
        question: '如何在飞书群顶部添加工单列表或者创建入口',
        answer: '您可以点击群标题栏的“+”号添加标签页，输入对应的地址即可增加工单快捷入口。建议在一些固定的问题反馈群、项目问题群中添加。所有工单：https: //applink.feishu.cn/client/web_app/open?appId=cli_a1e79252787a900c&mode=sidebar&path=%2Fexplore创建工单：https://applink.feishu.cn/client/web_app/open?appId=cli_a1e79252787a900c&mode=sidebar&path=%2Fticket%2Fnew'
    }
];
async function main() {
    const ret = [];
    for (const dataset of datasets) {
        const result = await openai
            .createEmbedding({ model: 'text-embedding-ada-002', input: `${dataset.question}\n${dataset.answer}` })
            .catch((e) => {
                console.log('error', e);
            });
        const vector = result?.data?.data[0].embedding;
        ret.push({ question: dataset.question, answer: dataset.answer, vector });
    }

    fs.writeFileSync('embeddings.json', JSON.stringify(ret));
}

main();
